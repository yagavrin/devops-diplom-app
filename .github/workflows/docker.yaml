name: CI & CD (build on commit, deploy on tag)

on:
  # push:
  #   branches: [ "main" ]
  #   tags: [ "v*" ]
  workflow_dispatch:

concurrency:
  group: docker-${{ github.ref }}
  cancel-in-progress: true

env:
  CR_REGISTRY: crpiop5kci1440r661pk
  CR_REPOSITORY: nginx
  DOCKERFILE: ./nginx/Dockerfile
  CONTEXT: nginx
  K8S_NAMESPACE: production
  K8S_DEPLOYMENT: nginx-app-deployment

jobs:
  # build_push:
  #   name: Prepare image
  #   runs-on: ubuntu-latest
  #   environment: prod 
  #   permissions:
  #     contents: read
  #     id-token: write
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Set up Docker Buildx
  #       uses: docker/setup-buildx-action@v3

  #     - name: Login to YCR
  #       uses: yc-actions/yc-cr-login@v3
  #       with:
  #         yc-sa-id: ${{ secrets.YC_SA_ID }}

  #     - name: Extract metadata (labels, tags)
  #       id: meta
  #       uses: docker/metadata-action@v5
  #       with:
  #         images: cr.yandex/${{ env.CR_REGISTRY }}/${{ env.CR_REPOSITORY }}
  #         tags: |
  #           type=raw,value=latest
  #           type=sha,format=short
  #           type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/') }}

  #     - name: Build & Push
  #       uses: docker/build-push-action@v6
  #       with:
  #         context: ${{ env.CONTEXT }}
  #         file: ${{ env.DOCKERFILE }}
  #         push: true
  #         platforms: linux/amd64
  #         tags: ${{ steps.meta.outputs.tags }}
  #         labels: ${{ steps.meta.outputs.labels }}
  #         cache-from: type=gha
  #         cache-to: type=gha,mode=max
  deploy:
    # needs: build_push
    # if: startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    environment: prod
    steps:
      # Step 1: Checkout the code (optional, but often useful for having scripts or configs)
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Install the SSH key and known_hosts
      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ls -la ~/ | grep .ssh || echo "No .ssh directory found"
          # Save the private key to a file with strict permissions
          cat > ~/.ssh/ssh_key << EOF
          ${{ secrets.BASTION_SSH_PRIVATE_KEY }}
          EOF
          chmod 600 ~/.ssh/ssh_key
          ls -la ~/.ssh/
          echo "Key file contents (first few chars):"
          head -c 100 ~/.ssh/ssh_key
          ssh-keygen -l -f ~/.ssh/ssh_key || echo "Key format issue detected"
          # Optionally, trust the bastion host's public key to avoid interactive prompt
          ssh-keyscan -H ${{ secrets.BASTION_HOST }} > ~/.ssh/known_hosts
          ssh -vvv -i ~/.ssh/ssh_key ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} "echo 'Connection successful'"
        shell: bash

      # Step 3: SSH into the bastion and run the command
      - name: Run kubectl get nodes on Bastion
        run: |
          ssh ${{ secrets.BASTION_USER }}@${{ secrets.BASTION_HOST }} "kubectl get nodes"
    # steps:
    #   - name: Install kubectl
    #     uses: azure/setup-kubectl@v4

    #   - name: Write kubeconfig (decode base64)
    #     run: |
    #       echo "${{ secrets.KUBE_CONFIG_B64 }}" | base64 -d > $GITHUB_WORKSPACE/kubeconfig
    #       echo "KUBECONFIG=$GITHUB_WORKSPACE/kubeconfig" >> $GITHUB_ENV

    #   - name: Show kubeconfig headers (debug)
    #     run: |
    #       head -n 5 "$KUBECONFIG" || true
    #       kubectl config view --minify || true
    #   - name: Start SSH tunnel
    #     run: |
    #       ssh -f -i $GITHUB_WORKSPACE/ssh_key \
    #         -o StrictHostKeyChecking=no \
    #         -L 6443:$:6443 user@bastion-host \
    #         -N
    #       echo "KUBECONFIG=$GITHUB_WORKSPACE/kubeconfig" >> $GITHUB_ENV
    #   - name: Get nodes
    #     run: |
    #       kubectl get nodes
      # - name: Set image to tag & rollout
      #   run: |
      #     IMG="cr.yandex/${{ env.CR_REGISTRY }}/${{ env.CR_REPOSITORY }}:${{ github.ref_name }}"
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" set image deployment/${{ env.K8S_DEPLOYMENT }} \
      #       ${{ env.K8S_DEPLOYMENT }}="$IMG"
      #     kubectl -n "${{ env.K8S_NAMESPACE }}" rollout status deployment/${{ env.K8S_DEPLOYMENT }}
